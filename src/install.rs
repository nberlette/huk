//! Hook installer module.
//!
//! This module provides functionality for generating executable wrapper scripts
//! in the Git hooks directory. Each wrapper script invokes the `huk` binary
//! with the appropriate `run` subcommand to execute configured tasks. The
//! installer respects the `core.hooksPath` Git configuration if present; if
//! unspecified, it falls back to the repository's `.git/hooks` directory.

use crate::cli::InstallOpts;
use crate::cli::UninstallOpts;
use crate::config::ConfigError;
use crate::config::HookConfig;
use std::env;
use std::fs;
#[cfg(target_family = "unix")]
use std::os::unix::fs::PermissionsExt;
#[cfg(target_family = "windows")]
use std::os::windows::fs::PermissionsExt;
use std::path::PathBuf;
use std::process::Command;
use thiserror::Error;

/// Errors that may occur during installation of hooks.
#[derive(Error, Debug)]
pub enum InstallError {
  /// Failed to load configuration.
  #[error(transparent)]
  Config(#[from] ConfigError),
  /// Failed to determine hook directory.
  #[error("failed to determine git hooks directory: {0}")]
  HooksDir(String),
  /// I/O error while writing files.
  #[error(transparent)]
  Io(#[from] std::io::Error),
}

/// Handle the `install` subcommand.
pub fn handle_install(opts: &InstallOpts) -> Result<(), InstallError> {
  let cfg =
    HookConfig::discover(&env::current_dir().map_err(InstallError::Io)?)?;
  let hooks_dir = find_git_hooks_dir(opts.hooks_dir.clone())?;
  // ensure the hooks directory exists.
  fs::create_dir_all(&hooks_dir)?;
  // Determine the path to the currently running binary. If this fails,
  // fallback to calling `huk` from PATH.
  let exe_path = env::current_exe().unwrap_or_else(|_| PathBuf::from("huk"));

  let mut hook_names: Vec<&String> = cfg.hooks.keys().collect();
  hook_names.sort();

  for hook_name in hook_names {
    let script_path = hooks_dir.join(hook_name);
    if script_path.exists() && !opts.force {
      eprintln!(
        "Skipping existing hook script '{}'; use --force to overwrite",
        script_path.display()
      );
      continue;
    }
    // Compose the wrapper script. Use exec so that signals propagate.
    let script = format!(
      "#!/bin/sh\n# Auto-generated by huk.\nexec {} run {} \"$@\"\n",
      escape_shell(&exe_path.display().to_string()),
      hook_name
    );
    fs::write(&script_path, script)?;
    // Make the script executable.
    let mut perms = fs::metadata(&script_path)?.permissions();
    perms.set_mode(0o755);
    fs::set_permissions(&script_path, perms)?;
    eprintln!("Installed hook script: {}", script_path.display());
  }
  Ok(())
}

pub fn handle_uninstall(opts: &UninstallOpts) -> Result<(), InstallError> {
  let hooks_dir = find_git_hooks_dir(opts.hooks_dir.clone())?;
  let cfg =
    HookConfig::discover(&env::current_dir().map_err(InstallError::Io)?)?;

  let mut hook_names: Vec<&String> = cfg.hooks.keys().collect();
  hook_names.sort();

  if hook_names.is_empty() {
    if opts.hooks.is_empty() {
      eprintln!("No hooks configured; nothing to uninstall.");
      return Ok(());
    }
    eprintln!("Uninstalling all configured hooks...");
    for hook_name in &opts.hooks {
      let script_path = hooks_dir.join(hook_name);
      // look for a backup file in case we overwrote an existing hook on
      // install.
      let maybe_backup_path = hooks_dir.join(format!("{}.bak", hook_name));
      if script_path.exists() {
        fs::remove_file(&script_path)?;
        if maybe_backup_path.exists() {
          fs::rename(&maybe_backup_path, &script_path)?;
          eprintln!(
            "Restored backup of original hook script: {}",
            script_path.display()
          );
        }
        eprintln!("Removed hook script: {}", script_path.display());
      } else {
        eprintln!(
          "Hook script '{}' does not exist; skipping",
          script_path.display()
        );
      }
    }
  } else {
    for hook_name in hook_names {
      if opts.hooks.is_empty() || opts.hooks.contains(hook_name) {
        let script_path = hooks_dir.join(hook_name);
        if script_path.exists() {
          fs::remove_file(&script_path)?;
          eprintln!("Removed hook script: {}", script_path.display());
        } else {
          eprintln!(
            "Hook script '{}' does not exist; skipping",
            script_path.display()
          );
        }
      }
    }
  }
  Ok(())
}

/// Determine the git hooks directory using `git config core.hooksPath` if set,
/// otherwise defaulting to `.git/hooks` relative to the repository root.
fn find_git_hooks_dir(
  user_hooks_dir: Option<String>,
) -> Result<PathBuf, InstallError> {
  // If the user provided a custom hooks directory, try to use that first.
  if let Some(dir) = user_hooks_dir {
    return Ok(PathBuf::from(dir));
  }
  // Try `git config core.hooksPath`.
  let output = Command::new("git")
    .args(["config", "--get", "core.hooksPath"])
    .output();
  if let Ok(out) = output
    && out.status.success()
  {
    let path_str = String::from_utf8_lossy(&out.stdout).trim().to_string();
    if !path_str.is_empty() {
      return Ok(PathBuf::from(path_str));
    }
  }
  // Fallback: locate the .git directory using `git rev-parse --git-dir`.
  let output = Command::new("git")
    .args(["rev-parse", "--git-dir"])
    .output();
  if let Ok(out) = output
    && out.status.success()
  {
    let git_dir = String::from_utf8_lossy(&out.stdout).trim().to_string();
    let hooks = PathBuf::from(git_dir).join("hooks");
    return Ok(hooks);
  }
  Err(InstallError::HooksDir(
    "unable to determine git hooks directory".into(),
  ))
}

/// Escape a string for safe use in shell scripts. This implementation wraps
/// values containing whitespace in single quotes and escapes existing single
/// quotes. If the string contains no spaces it is returned unchanged.
fn escape_shell(s: &str) -> String {
  if s.contains(' ') {
    // Replace single quotes with '\''; this ends the single-quoted string,
    // inserts a literal single quote, then reopens single quotes.
    let escaped = s.replace("'", "'\\''");
    format!("'{}'", escaped)
  } else {
    s.to_string()
  }
}
