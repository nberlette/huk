//! Hook installer module.
//!
//! This module provides functionality for generating executable wrapper scripts
//! in the Git hooks directory. Each wrapper script invokes the `huk` binary
//! with the appropriate `run` subcommand to execute configured tasks. The
//! installer respects the `core.hooksPath` Git configuration if present; if
//! unspecified, it falls back to the repository's `.git/hooks` directory.

use crate::cli::InstallOpts;
use crate::config::ConfigError;
use crate::config::HookConfig;
use std::env;
use std::fs;
use std::os::unix::fs::PermissionsExt;
use std::path::PathBuf;
use std::process::Command;
use thiserror::Error;

/// Errors that may occur during installation of hooks.
#[derive(Error, Debug)]
pub enum InstallError {
  /// Failed to load configuration.
  #[error(transparent)]
  Config(#[from] ConfigError),
  /// Failed to determine hook directory.
  #[error("failed to determine git hooks directory: {0}")]
  HooksDir(String),
  /// I/O error while writing files.
  #[error(transparent)]
  Io(#[from] std::io::Error),
}

/// Handle the `install` subcommand.
pub fn handle_install(opts: &InstallOpts) -> Result<(), InstallError> {
  let cfg = HookConfig::discover(
    &env::current_dir().map_err(|e| InstallError::Io(e))?,
  )?;
  let hooks_dir = find_git_hooks_dir()?;
  fs::create_dir_all(&hooks_dir)?;
  // Determine the path to the currently running binary. If this fails,
  // fallback to calling `huk` from PATH.
  let exe_path = env::current_exe().unwrap_or_else(|_| PathBuf::from("huk"));

  for (hook_name, _spec) in &cfg.hooks {
    let script_path = hooks_dir.join(hook_name);
    if script_path.exists() && !opts.force {
      println!(
        "Skipping existing hook script '{}'; use --force to overwrite",
        script_path.display()
      );
      continue;
    }
    // Compose the wrapper script. Use exec so that signals propagate.
    let script = format!(
      "#!/bin/sh\n# Auto-generated by huk.\nexec {} run {} \"$@\"\n",
      escape_shell(&exe_path.display().to_string()),
      hook_name
    );
    fs::write(&script_path, script)?;
    // Make the script executable.
    let mut perms = fs::metadata(&script_path)?.permissions();
    perms.set_mode(0o755);
    fs::set_permissions(&script_path, perms)?;
    println!("Installed hook script: {}", script_path.display());
  }
  Ok(())
}

/// Determine the git hooks directory using `git config core.hooksPath` if set,
/// otherwise defaulting to `.git/hooks` relative to the repository root.
fn find_git_hooks_dir() -> Result<PathBuf, InstallError> {
  // Try `git config core.hooksPath`.
  let output = Command::new("git")
    .args(["config", "--get", "core.hooksPath"])
    .output();
  if let Ok(out) = output {
    if out.status.success() {
      let path_str = String::from_utf8_lossy(&out.stdout).trim().to_string();
      if !path_str.is_empty() {
        return Ok(PathBuf::from(path_str));
      }
    }
  }
  // Fallback: locate the .git directory using `git rev-parse --git-dir`.
  let output = Command::new("git")
    .args(["rev-parse", "--git-dir"])
    .output();
  if let Ok(out) = output {
    if out.status.success() {
      let git_dir = String::from_utf8_lossy(&out.stdout).trim().to_string();
      let hooks = PathBuf::from(git_dir).join("hooks");
      return Ok(hooks);
    }
  }
  Err(InstallError::HooksDir(
    "unable to determine git hooks directory".into(),
  ))
}

/// Escape a string for safe use in shell scripts. This implementation wraps
/// values containing whitespace in single quotes and escapes existing single
/// quotes. If the string contains no spaces it is returned unchanged.
fn escape_shell(s: &str) -> String {
  if s.contains(' ') {
    // Replace single quotes with '\''; this ends the single-quoted string,
    // inserts a literal single quote, then reopens single quotes.
    let escaped = s.replace("'", "'\\''");
    format!("'{}'", escaped)
  } else {
    s.to_string()
  }
}
